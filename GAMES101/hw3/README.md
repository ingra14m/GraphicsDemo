## TODO
- 软光栅化的插值，alpha、betta、gamma
- alpha blend为什么以像素级 还会出现交叉遮挡的情况
  - 难道是因为Transparent队列的深度不是以像素级？因为上来要对物体排序？所以在对物体排序的同时页判定了深度？

## 变换模型空间的法线

不能简单地使用MVP矩阵直接乘，切线可以。我们需要推导：

- 简单来说就是逆 + 转秩

![](README.assets/image-20220703215959323.png)

## 光栅化插值

### 求重心坐标

已知三角形重心坐标，求三角形内某点，我们可以根据$\alpha + \beta + \gamma = 1$来求


![image-20220703220836254](README.assets/image-20220703220836254.png)

```c++
static std::tuple<float, float, float> computeBarycentric2D(float x, float y, const Vector4f *v) {
    float c1 = (x * (v[1].y() - v[2].y()) + (v[2].x() - v[1].x()) * y + v[1].x() * v[2].y() - v[2].x() * v[1].y()) /
               (v[0].x() * (v[1].y() - v[2].y()) + (v[2].x() - v[1].x()) * v[0].y() + v[1].x() * v[2].y() -
                v[2].x() * v[1].y());
    float c2 = (x * (v[2].y() - v[0].y()) + (v[0].x() - v[2].x()) * y + v[2].x() * v[0].y() - v[0].x() * v[2].y()) /
               (v[1].x() * (v[2].y() - v[0].y()) + (v[0].x() - v[2].x()) * v[1].y() + v[2].x() * v[0].y() -
                v[0].x() * v[2].y());
    float c3 = (x * (v[0].y() - v[1].y()) + (v[1].x() - v[0].x()) * y + v[0].x() * v[1].y() - v[1].x() * v[0].y()) /
               (v[2].x() * (v[0].y() - v[1].y()) + (v[1].x() - v[0].x()) * v[2].y() + v[0].x() * v[1].y() -
                v[1].x() * v[0].y());
    return {c1, c2, c3};
}
```

### 求深度

这个深度，其实是在NDC下的深度，抑或是经过MVP还没除w的深度。因为使用的深度是那个坐标系的。

要记住，通过重心就可以求出比例

插值得到的无非是一个精确度的问题。

深度得到的并不是MV空间下的，而是经过了透视投影压缩的

其他法线就可以直接通过重心得到准确的数值

![](README.assets/image-20220703231802896.png)

```c++
float Z = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());  // 这里用w是不准确的，因为在本例中接近才这样
float zp = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();
zp *= Z;  // 插值得到该像素点的深度
```

- Z对应9
- zp对应10的前半部分
- 这里用w代替MVP后的z是不准确的，因为两者不相等。只是用这个做trick，用来比较想对深度而以，不需要纠结



## 我的实现

- 重心坐标插值的核心算法不动，就是在屏幕空间下做二维三角形插值

- 对于深度Z和其他属性的插值进行了改动

  - 使用了$\dfrac{1}{Z}$进行矫正
  - view空间下，真正的插值后的像素对应位置的深度应该为如下公式，其中Z1、Z2、Z3都是view空间下的顶点深度，可以通过NDC下的w通道获取。（这是因为Projection矩阵的最后一行为0010，w = z）

  $$
  Z = \dfrac{1}{\dfrac{alpha}{Z1} + \dfrac{beta}{Z2} + \dfrac{gamma}{Z3}}
  $$

  - 在mvp变换之后，我们应当做硬件除法，对其他所有的属性都要除w
  - 在光栅化插值的时候，插值公式应当为：
    - 插值经过透视投影之前空间的属性：其中这个$I_A$只要是在透视投影之前即可，view、world甚至model都可以
    - 插值经过透视投影之后的空间，直接alpha、beta、gamma直接乘就可以了

  $$
  I = Z \times (alpha \times I_A + beta \times I_B + gamma \times I_C)
  $$

  

  ## 问题

  - 注意正交投影的近平面n，相对于摄像机来说，其实他的坐标更大

  - **参与深度测试的z**
    - 我们尝试了view空间下的插值Z，结果误差非常大，很多fragment都被剔除。
    - 直接**使用NDC的z**：也会有少量的阴影，猜测是差距太小了，精度问题
    - 变换回**正交投影之前**：因为透视投影可以理解为两个过程，先压缩，再做正交，这个是可以的。有点疑惑，不知道是为啥。猜测是拉大了差距？不太清楚
      - 因为是NDC[-1，1]，所以在NDC下求正交投影前的那个块中的位置很简单，就是乘长度 + 中心点的位置
      - 千万不能用正交矩阵反推，因为此时的view空间坐标经过projection，$z_p = z_v * value + value$，w已经不是1了
      - 我们反向求正交矩阵坐标系下的位置，完全可以从NDC反推回去，但是那样完全没有必要。因为我们看的是相对值，而不是一个绝对的坐标信息。因此我们直接在那个立方体坐标系下就行，转换到n-f坐标系下。相当于z的屏幕映射。这样坐标范围就是n-f了
  - 没有做culling
    - 视锥剔除没有做
    - NDC超过-1-1的部分没有处理